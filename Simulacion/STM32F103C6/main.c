/* Main.c file generated by New Project wizard
 *
 * Created:   Tue Jan 18 2022
 * Processor: STM32F103C6
 * Compiler:  Keil for ARM
 */

#include <stm32f103x6.h>
#include <spi_config.h>
#include <max7219.h>
#include <stdlib.h>
#include <string.h>

struct cell 
{
   uint8_t previous_state;
   uint8_t current_state;
   uint8_t next_state;
};



void delay_ms(uint16_t time)
{  //Funcion de retardo
   volatile unsigned long l = 0;
   uint16_t i;

   for(i = 0; i < time; i++)
   {
      for(l = 0; l < 800; l++);
   }
}

int main (void)
{ 
// Write your code here

   struct cell playboard[8][8];

   uint8_t led_matrix[8][8] = {
                           {0},
                           {0},
                           {0},
                           {0},
                           {0},
                           {0},
                           {0},
                           {0},
   };

   int i,j;

   spi_init();
   max7219_init();
   for(i = 0; i < 8; i++)
   {
      for(j = 0; j < 8; j++)
      {
         playboard[0][0].previous_state = 0;
         playboard[0][0].current_state = 0;
         playboard[0][0].next_state = 0;
         playboard[0][0].previous_state = 0;
         playboard[0][0].current_state = 0;
         playboard[0][0].next_state = 0;
      }
   }
   playboard[0][0].previous_state = 0;
   playboard[0][0].current_state = 1;
   playboard[0][0].next_state = 0;



   while (1)
   {
      for (i = 0; i < 8; i++)
      {
         for (j = 0; j < 8; j++)
         {
            led_matrix[i][j] = playboard[i][j].current_state;
         }
      }

      max7219_load(led_matrix);
      max7219_refresh();

      for (i = 0; i < 8; i++)
      {
         for (j = 0; j < 8; j++)
         {
            
            playboard[i][j].previous_state = playboard[i][j].current_state;

            if (playboard[i][j].previous_state == 1)
            {
               playboard[i][j].current_state = 0;
            }
            else
            { 
               if (i-1 >= 0)
               {
                  playboard[i][j].current_state = playboard[i-1][j].previous_state;
               }
               if (j-1 >= 0)
               {
                  playboard[i][j].current_state = playboard[i][j-1].previous_state;
               }
               if (i-1 >= 0 && j-1 >= 0)
               {
                  playboard[i][j].current_state = playboard[i-1][j-1].previous_state;
               }
            }
         }
      }
      delay_ms(1000);
   }

}   
